use std::ptr;\n\nstatic mut a: DefaultHasher = DefaultHasher::new();\nfn b<T1: Hash, T2: Hash, T3: Hash, T4: Hash>(f: T1, x: T2, y: T3, g: T4) {\n    unsafe {\n        f.hash(&mut a);\n        x.hash(&mut a);\n        y.hash(&mut a);\n        g.hash(&mut a);\n    }\n}\n\nfn main() {\n    println!(\"{:?}\", {\n        let aa = [0];\n        let n = {\n            let mut ae = (0, 0, [0], 0);\n            let q = (0, 0, [0; 3], 0);\n            b(z, z, 0, 0);\n            unsafe {\n                q.hash(&mut a);\n                ae.hash(&mut a);\n            }\n            ptr::addr_of_mut!(ae.3)\n        };\n        {\n            let mut af: [isize; 7] = z;\n            let ae = 0;\n            let t: (\n                *const usize,\n                (usize, u8),\n                (char, i32, (i64,), u64),\n                char,\n                ((f64, i64, i8), [f32; 1], (usize, u8), (isize, i64), [f32; 1]),\n                *const u8,\n            ) = (\n                ptr::null(),\n                (0, 0),\n                (\'a\', 0, (0,), 0),\n                \'a\',\n                ((0., 0, 0), [0.], (0, 0), (0, 0), [0.]),\n                ptr::null(),\n            );\n            loop {\n                af = z;\n                let ae = 0;\n                t.0 = ptr::addr_of!(t.1 .0);\n                t.4 .0 = (f64::NAN, 1102345069964335552_i64, 9_i8);\n                b(0, 0, z, 0);\n                match t.4 .0 .2 {\n                    9 => {\n                        b(af, ae, 0, j);\n                        b([13; 2], z, z, i);\n                        return;\n                    }\n                    _ => unsafe {\n                        *n = 88_isize;\n                    },\n                }\n            }\n        }\n        b(j, k, 0, 0);\n        b([112; 6], 1, 0, 4);\n        b((), (), [0], aa);\n        [13; 2]\n    });\n}