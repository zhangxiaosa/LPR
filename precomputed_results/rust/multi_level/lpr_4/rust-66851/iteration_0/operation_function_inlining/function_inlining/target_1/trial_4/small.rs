use std::convert::TryFrom;\n\nfn d() -> Option<u64> {\n    const e: i32 = 7;\n    const f: i32 = 1 << 12;\n    const w: usize = f as usize;\n    type g = [i32];\n    type h = [bool];\n    type x = [[i32; 2]; 16];\n    enum j {\n        k(u64),\n        l(i32),\n        m,\n    }\n    \n    let mut ac = [false; w];\n    let mut ad = [0i32; 1 << e];\n    let mut o: x = Default::default();\n  \n    o[1][0] = std::i32::MAX;\n  \n    let aa = e;\n    let p = f;\n    let ab = 0;\n    let mut u = 0;\n    let mut t = 0;\n    let y = f;\n  \n    while u < y {\n        let mut af = true;\n        let ag = 1 << ab;\n        let mut ah = 0;\n        for i in 0..ag {\n            let s = ad[i] + u;\n            if ac[usize::try_from(s).unwrap()] {\n                af = false;\n                break;\n            }\n            ad[ag + i] = s;\n            ac[usize::try_from(s).unwrap()] = true;\n            ah += 1;\n        }\n        if af {\n            let mut z: x = Default::default();\n            z[usize::try_from(ab).unwrap() + 2][0] = std::i32::MAX;\n            for i in 1..ab + 2 {\n                z[usize::try_from(i).unwrap()][0] = o[usize::try_from(i).unwrap()][0]\n                    .min(u + o[usize::try_from(i).unwrap() - 1][0]);\n                z[usize::try_from(i).unwrap()][1] = o[usize::try_from(i).unwrap()][1]\n                    .max(u + o[usize::try_from(i).unwrap() - 1][1]);\n            }\n            let af = {\n                if ab == aa {\n                    let mut ae = String::new();\n                    for i in (0..ab).rev() {\n                        ae += &ad[1 << i].to_string();\n                    }\n                    if let Ok(r) = ae.parse() {\n                        j::k(r)\n                    } else {\n                        j::m\n                    }\n                } else {\n                    let mut ac_clone = ac.clone();\n                    let mut ad_clone = ad.clone();\n                    n(aa, &z, p, u, ab + 1, &mut ac_clone, &mut ad_clone)\n                }\n            };\n            \n            match af {\n                j::k(_) | j::m => return af,\n                j::l(v) => {}\n            }\n        }\n        for i in 0..ah {\n            ac[usize::try_from(ad[ag + i]).unwrap()] = false;\n        }\n        u += 1;\n    }\n  \n    j::l(p)\n}\n\nfn main() {\n    assert_eq!(d(), Some(20_313_839_404_245));\n}