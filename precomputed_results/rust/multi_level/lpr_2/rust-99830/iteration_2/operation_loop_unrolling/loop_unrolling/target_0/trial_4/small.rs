use primal_sieve::Primes;\nfn main() {\n\tlet b = 4;\n\tlet mut c = d(1);\n\tPrimes::all().take_while(|&e| e < b as usize).for_each(|e| {\n\t\tlet e = e as u32;\n\t\t// Unrolled iteration 1\n\t\tlet f1 = b / e;\n\t\tlet base1 = d(e).pow(2 * f1);\n\t\tc *= base1 + d(1);\n\t\t// Unrolled iteration 2\n\t\tlet f2 = b / e;\n\t\tlet base2 = d(e).pow(2 * f2);\n\t\tc *= base2 + d(1);\n\t\t// Unrolled iteration 3\n\t\tlet f3 = b / e;\n\t\tlet base3 = d(e).pow(2 * f3);\n\t\tc *= base3 + d(1);\n\t\t// ...\n\t});\n\tassert_eq!(c.0, 650);\n}\n\n#[derive(Clone, Copy)]\nstruct d(u32);\nimpl d {\n\tconst G: u32 = 10u32.pow(9);\n\tfn pow(self, mut exp: u32) -> Self {\n\t\tlet mut base = self;\n\t\tbase *= base;\n\t\texp >>= 1;\n\t\tlet mut acc = base;\n\t\texp >>= 1;\n\t\tbase *= base;\n\t\tif exp == 1 {\n\t\t\tacc *= base;\n\t\t}\n\t\tacc\n\t}\n}\nimpl core::ops::Add for d {\n\ttype Output = d;\n\tfn add(mut self, h: d) -> d {\n\t\tself.0 += h.0;\n\t\tself\n\t}\n}\nimpl core::ops::MulAssign for d {\n\tfn mul_assign(&mut self, h: d) {\n\t\tunsafe {\n\t\t\tcore::arch::asm!(\n\t\t\t\t"mul edx",\n\t\t\t\t"div {}",\n\t\t\t\tin(reg) Self::G,\n\t\t\t\tinout("eax") h.0 => _,\n\t\t\t\tinout("edx") self.0\n\t\t\t);\n\t\t}\n\t}\n}