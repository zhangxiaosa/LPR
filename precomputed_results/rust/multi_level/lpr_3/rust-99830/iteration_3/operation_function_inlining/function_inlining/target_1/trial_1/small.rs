use primal_sieve::Primes;\nuse std::ops::Add;\n\nfn main() {\n    let mut c = d(1);\n    Primes::all()\n        .take_while(|&e| e < 4)\n        .for_each(|e| {\n            let h = d(e as u32).pow(8 / e as u32) + d(1);\n            unsafe {\n                core::arch::asm!(\n                    \"mul edx\",\n                    \"div {:e}\",\n                    in(reg) d::g,\n                    inout(\"eax\") h.0 => _,\n                    inout(\"edx\") c.0\n                );\n            }\n        });\n    assert_eq!(c.0, 650);\n}\n\n#[derive(Clone, Copy)]\nstruct d(u32);\n\nimpl Add for d {\n    type Output = d;\n    fn add(mut self, h: d) -> d {\n        self.0 += h.0;\n        self\n    }\n}\n\nimpl d {\n    const g: u32 = 1000000000;\n\n    fn pow(self, mut exp: u32) -> Self {\n        let mut base = self;\n        base *= base;\n        exp >>= 1;\n        let mut acc = base;\n        exp >>= 1;\n        base *= base;\n        if exp == 1 {\n            acc *= base;\n        }\n        acc\n    }\n}