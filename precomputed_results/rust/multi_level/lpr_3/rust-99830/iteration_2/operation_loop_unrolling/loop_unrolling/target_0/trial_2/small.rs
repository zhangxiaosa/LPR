# The target to be optimized is Primes::all().take_while(|&e| e < 4).for_each(|e| {.\n\nuse primal_sieve::Primes;\nuse std::ops::{Add, MulAssign};\n\nfn main() {\n    let mut c = d(1);\n\n    // Loop unrolling for primes in [2, 3]\n\n    // Unrolled iteration 1: e = 2\n    {\n        let e = 2;\n        let f = 4 / e as u32;\n        c *= d(e as u32).pow(2 * f) + d(1);\n    }\n    \n    // Unrolled iteration 2: e = 3\n    {\n        let e = 3;\n        let f = 4 / e as u32;\n        c *= d(e as u32).pow(2 * f) + d(1);\n    }\n    \n    assert_eq!(c.0, 650);\n}\n\n#[derive(Clone, Copy)]\nstruct d(u32);\n\nimpl d {\n    const g: u32 = 1000000000;\n}\n\nimpl Add for d {\n    type Output = d;\n    fn add(mut self, h: d) -> d {\n        self.0 += h.0;\n        self\n    }\n}\n\nimpl MulAssign for d {\n    fn mul_assign(&mut self, h: d) {\n        unsafe {\n            core::arch::asm!(\n                "mul edx",\n                "div {:e}",\n                in(reg) Self::g,\n                inout("eax") h.0 => _,\n                inout("edx") self.0\n            );\n        }\n    }\n}\n\nimpl d {\n    fn pow(self, mut exp: u32) -> Self {\n        let mut base = self;\n        base *= base;\n        exp >>= 1;\n        let mut acc = base;\n        exp >>= 1;\n        base *= base;\n        if exp == 1 {\n            acc *= base;\n        }\n        acc\n    }\n}