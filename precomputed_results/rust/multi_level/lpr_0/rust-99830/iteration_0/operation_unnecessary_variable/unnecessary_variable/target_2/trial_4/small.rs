use primal_sieve::Primes;\nuse std::ops::{Add, MulAssign};\n\nfn main() {\n\tassert_eq!(a(4), 650);\n}\n\n#[inline(never)]\nfn a(b: u32) -> u32 {\n\tPrimes::all().take_while(|&e| e < b as usize).for_each(|e| {\n\t\tlet e = e as u32;\n\t\tlet f = b / e;\n\t\td(1) *= d(e).pow(2 * f) + d(1);\n\t});\n\td(1).0\n}\n\n#[derive(Clone, Copy)]\nstruct d(u32);\n\nimpl d {\n\tconst g: u32 = 10u32.pow(9);\n\n\tfn pow(self, mut exp: u32) -> Self {\n\t\tlet mut base = self;\n\t\tbase *= base;\n\t\texp >>= 1;\n\t\tlet mut acc = base;\n\t\texp >>= 1;\n\t\tbase *= base;\n\t\tif exp == 1 {\n\t\t\tacc *= base;\n\t\t}\n\t\tacc\n\t}\n}\n\nimpl Add for d {\n\ttype Output = d;\n\n\tfn add(mut self, h: d) -> d {\n\t\tself.0 += h.0;\n\t\tself\n\t}\n}\n\nimpl MulAssign for d {\n\tfn mul_assign(&mut self, h: d) {\n\t\tunsafe {\n\t\t\tcore::arch::asm!(\n\t\t\t\t"mul edx",\n\t\t\t\t"div {:e}",\n\t\t\t\tin(reg) Self::g,\n\t\t\t\tinout("eax") h.0 => _,\n\t\t\t\tinout("edx") self.0\n\t\t\t);\n\t\t}\n\t}\n}